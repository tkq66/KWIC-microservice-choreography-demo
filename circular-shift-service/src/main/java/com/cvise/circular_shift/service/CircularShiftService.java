package com.cvise.circular_shift.service;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.stream.Stream;

import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import com.cvise.circular_shift.exception.HttpFileTransferFailed;
import com.cvise.circular_shift.exception.NotFoundException;
import com.cvise.circular_shift.entity.KeywordsInContext;
import com.cvise.circular_shift.respository.KeywordsInContextRepository;
import com.cvise.circular_shift.respository.KeywordsInContextRepositoryCustomImpl;

import reactor.core.publisher.Mono;

import com.cvise.circular_shift.exception.FileStorageException;
import com.cvise.circular_shift.exception.FileReadException;

@Service
public class CircularShiftService {
	@Value("${user.home}")
    private String localFilesReferenceDir;
    @Value("${user.local.static.file.path}")
	private String staticFilePath;
	@Value("${user.local.static.file.endpoint}")
	private String staticFileEndpoint;

	private KeywordsInContextRepository repository;
	private KeywordsInContextRepositoryCustomImpl customRepository;
    public CircularShiftService(KeywordsInContextRepository repository,
    							KeywordsInContextRepositoryCustomImpl customRepository) {
    	this.repository = repository;
    	this.customRepository = customRepository;
    }
    
    /**Return list of string of keywords in context by id.
     * 
     * @param id String of KeywordsInContext id.
     * @return List of string of keywords in context.
     */
    public List<String> getKeywordsById(String id) {
    	KeywordsInContext keywords = repository.findById(id).orElseThrow(NotFoundException::new);
    	return keywords.getKeywords();
    }
    
    /**Return URL to the static file of keywords in context with a certain id.
     * 
     * @param id String of KeywordsInContext id to get keywords data from.
     * @param request HttpServletRequest to construct the base URL from.
     * @return String of URL to the static file location. 
     */
    public String saveKeywordsToFileById(String id, HttpServletRequest request) {
    	String baseUrl = getStaticFilesUrlFromRequest(request);
    	List<String> keywordsList = this.getKeywordsById(id);
    	String fileName = UUID.randomUUID().toString() + ".txt";
		String filePath = staticFilePath + fileName;
    	Path fileLocation = Paths.get(filePath);
    	try {
	    	Files.write(fileLocation, keywordsList);
	    	return baseUrl + fileName;
    	} catch (Exception e) {
            e.printStackTrace();
            throw new FileStorageException(
            	"Could not prepare file of input id " + id 
            	+ " for download at " + fileLocation.getFileName()
                + ". Please try again!");
        }
    }
    
    /**Perform circular shift on a text to get list of keywords in context.
     * 
     * @param input String of input data to perform circular shift to
     * 		  create keywords in context.
     * @return List of string of keywords in context.
     */
    public List<String> getKeywordsInContextForText(String input) {
    	List<String> keywordsInContext = new ArrayList<>();
    	List<String> inputList = Arrays.asList(input.split(" "));
    	int inputListSize = inputList.size();
    	for (int i = 0; i < inputListSize; i++) {	
    		keywordsInContext.add(String.join(" ", inputList));
    		Collections.rotate(inputList, 1); 
    	}
    	return keywordsInContext;
    }
    
    /**Store keywords in context that was generated by the text input
     * into a database.
     * 
     * @param entityId String of id of entity inside the database to
     * 		  store the keyword.
     * @param input String of input data to perform circular shift to
     * 		  create keywords in context.
     */
    public void storeAllKeywordsInContextsToDatabase(String entityId, String input) {
    	List<String> keywordsInContext = getKeywordsInContextForText(input);
    	for (String keywordInContext : keywordsInContext) {
    		customRepository.pushUniqueKeywordById(entityId, keywordInContext);
    	}
    }
    
    /**Store keywords in context that was generated by the content of a text file
     * into a database, then remove the file.
     * 
     * @param path String of path to  local file of text to perform circular shift.
     * @return String of entity id for element that stored the keywords.
     */
    public String storeAllKeywordsInContextFromFileToDatabase(String path) {
    	Path localFilePath = Paths.get(path);
    	try (Stream<String> stream = Files.lines(localFilePath)) {
    		KeywordsInContext newKeywords = repository.save(new KeywordsInContext(new ArrayList<String>()));
			String keywordsId = newKeywords.getId();
			stream.forEach((line -> { storeAllKeywordsInContextsToDatabase(keywordsId, line); }));
			Files.deleteIfExists(localFilePath);
			return keywordsId;
		} catch (IOException e) {
			e.printStackTrace();
			throw new FileReadException("Could not store file "
				+ localFilePath.toString()
                + " as keywords in context into the database. Please try again!");
		}
    }
    
    /**Upload file from a URL location that was generated by
     * an API endpoint to a local location.
     * 
     * @param apiUrl String of API endpoint to make http request
     * 		  for the file location.
     * @param requestMethod String of REST verb to make the http
     * 		  request with.
     * @param contentType String of MIME of expected result from
     * 		  the http request. In this case, the MIME type should
     * 		  be "text/plain" since a String of URL of file location
     * 		  is expected from the API call.
     * @return String of path to local file 
     */
    public String uploadFileFromApiRequest(String apiUrl,
    									   String requestMethod,
    									   String contentType) {
    	String urlToDataFile = getStringFromHttpRequest(
    			apiUrl,
    			requestMethod,
    			contentType);
    	String pathToLocalFile = uploadFileFromLink(urlToDataFile);
    	return pathToLocalFile;
    }

    /**Make an http request to an URL that must respond with a String.
     * 
     * @param url String of API endpoint to make http request.
     * @param requestMethod String of REST verb to make the request with.
     * @param contentType String of MIME of expected return content type.
     * @return String response from the http request.
     */
    public String getStringFromHttpRequest(String url,
    									   String requestMethod,
    									   String contentType) {
    	Mono<String> result = WebClient.create(url)
	    			    .method(HttpMethod.resolve(requestMethod))
	    			    .accept(MediaType.parseMediaType(contentType))
	    			    .retrieve()
	    			    .bodyToMono(String.class);
    	return result.block();
    }
    
    /**Efficiently upload file from a given URL to a local location
     * by using the stream transfer function.  
     * 
     * @param url String of URL to data file.
     * @return String of path to local file 
     */
    public String uploadFileFromLink(String url) {
    	String localFileName = UUID.randomUUID().toString() + ".txt";
		String localFilePath = localFilesReferenceDir + File.separator + localFileName;
    	try {
    		// Connect to the external and local file location
    		InputStream conStream = new URL(url).openStream();
    		FileOutputStream fileOutputStream = new FileOutputStream(localFilePath);
    		
    		// Stream the file to local path
    		ReadableByteChannel readableByteChannel = Channels.newChannel(conStream);
			fileOutputStream.getChannel()
			  .transferFrom(readableByteChannel, 0, Long.MAX_VALUE);
			
			// Clean up
			fileOutputStream.close();
			
			// Return path if transfer happens properly
			return localFilePath;
		} catch (IOException e) {
			e.printStackTrace();
			throw new HttpFileTransferFailed(
	            	"Failed to download file from " + url
	            	+ " to " + localFilePath
	            	+ ". Please try again!");
		}
    }
    
	
	/**Generate URL string to the location to static files being hosted.
	 * 
	 * @param request HttpServletRequest from the controller to extract info from.
	 * @return String of URL pointing to static files location.
	 */
	public String getStaticFilesUrlFromRequest(HttpServletRequest request) {
		return String.format("%s://%s:%d%s",
			request.getScheme(),
			request.getServerName(),
			request.getServerPort(),
			staticFileEndpoint);
	}
}
